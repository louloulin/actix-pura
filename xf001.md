# DataFlare Actoræ¨¡å‹æ”¹è¿›æ–¹æ¡ˆ

## æ•°æ®æµç¨‹åˆ†æ

DataFlareçš„æ•°æ®å¤„ç†æµç¨‹æ˜¯åŸºäºActoræ¨¡å‹å®ç°çš„ï¼Œä¸»è¦åŒ…å«ä»¥ä¸‹æ ¸å¿ƒç»„ä»¶ï¼š

1. **WorkflowActor**ï¼š
   - å·¥ä½œæµçš„ä¸­å¤®åè°ƒå™¨
   - ç®¡ç†å·¥ä½œæµçš„ç”Ÿå‘½å‘¨æœŸï¼ŒåŒ…æ‹¬å¯åŠ¨ã€æš‚åœã€æ¢å¤å’Œåœæ­¢
   - è·Ÿè¸ªå·¥ä½œæµçŠ¶æ€å’Œè¿›åº¦
   - ç»´æŠ¤å·¥ä½œæµä¸­æ‰€æœ‰ä»»åŠ¡å’Œç»„ä»¶çš„å¼•ç”¨

2. **SourceActor**ï¼š
   - è´Ÿè´£ä»å¤–éƒ¨æ•°æ®æºæå–æ•°æ®
   - ç®¡ç†è¿æ¥å™¨(Connector)å®ä¾‹ï¼Œç”¨äºè¯»å–ç‰¹å®šæ•°æ®æº
   - å°†è¯»å–çš„æ•°æ®æ‰¹æ¬¡åŒ–(batching)
   - åº”å½“å°†å¤„ç†åçš„æ•°æ®ä¼ é€’ç»™TaskActor

3. **TaskActor**ï¼š
   - å¤„ç†æ•°æ®æµçš„ä¸»è¦å•å…ƒ
   - æ ¹æ®ä»»åŠ¡ç±»å‹(Source/Transform/Destination)æ‰§è¡Œä¸åŒæ“ä½œ
   - å»ºç«‹ä»»åŠ¡é—´çš„ä¸‹æ¸¸å…³ç³»ï¼Œå½¢æˆæ•°æ®æµå›¾(DAG)
   - è´Ÿè´£å°†å¤„ç†åçš„æ•°æ®ä¼ é€’ç»™ä¸‹æ¸¸ä»»åŠ¡

4. **è¿æ¥å™¨(Connector)**ï¼š
   - å°è£…ç‰¹å®šæ•°æ®æº/ç›®æ ‡çš„è¯»å†™é€»è¾‘
   - ç”±SourceActorå’ŒTaskActorä½¿ç”¨
   - æä¾›æ‰¹é‡è¯»å–å’Œå†™å…¥èƒ½åŠ›

## é—®é¢˜æ·±åº¦åˆ†æ

é€šè¿‡å¯¹å½“å‰DataFlareæ¡†æ¶çš„ä»£ç åˆ†æï¼Œæˆ‘ä»¬å‘ç°æ•°æ®æµæ— æ³•æ­£å¸¸å·¥ä½œçš„æ ¸å¿ƒé—®é¢˜å¦‚ä¸‹ï¼š

1. **æ•°æ®æºä¸ä»»åŠ¡æ–­è¿**ï¼šâœ…
   - `SourceActor`è´Ÿè´£ä»è¿æ¥å™¨è¯»å–æ•°æ®ï¼Œä½†ä¸`TaskActor`æ²¡æœ‰æ­£ç¡®å…³è”
   - ç¼ºå°‘æ˜ç¡®çš„æœºåˆ¶å°†æ•°æ®ä»`SourceActor`ä¼ é€’åˆ°`TaskActor`ç³»ç»Ÿä¸­
   - `SourceActor`åœ¨è¯»å–æ•°æ®åæ²¡æœ‰æ­£ç¡®çš„ç›®æ ‡æ¥å‘é€æ•°æ®

2. **è§¦å‘é“¾ä¸å®Œæ•´**ï¼šâœ…
   - å·¥ä½œæµå¯åŠ¨æ—¶ï¼Œè™½ç„¶è°ƒç”¨äº†`StartWorkflow`ï¼Œä½†æ²¡æœ‰æ­£ç¡®è§¦å‘`SourceActor`çš„`StartExtraction`æ“ä½œ
   - `WorkflowActor`ã€`SourceActor`å’Œ`TaskActor`ä¹‹é—´çš„åè°ƒæœºåˆ¶ä¸å®Œå–„
   - å½“ä¸€ä¸ªç»„ä»¶å¯åŠ¨æˆ–çŠ¶æ€å˜åŒ–æ—¶ï¼Œæ²¡æœ‰æ­£ç¡®é€šçŸ¥ç›¸å…³ç»„ä»¶

3. **æ•°æ®æµé€šè·¯é˜»å¡**ï¼šâœ…
   - è™½ç„¶ä½¿ç”¨`AddDownstream`å»ºç«‹äº†æºä»»åŠ¡å’Œç›®æ ‡ä»»åŠ¡çš„ä¸‹æ¸¸å…³ç³»
   - ä½†æºæ•°æ®æœªèƒ½æµå…¥ä»»åŠ¡å¤„ç†ç³»ç»Ÿï¼Œå¯¼è‡´ç›®æ ‡æ–‡ä»¶æœªè¢«åˆ›å»º
   - ç¼ºå°‘æ•°æ®æµç›‘æ§å’Œå¼‚å¸¸å¤„ç†æœºåˆ¶

4. **å¼‚æ­¥æ‰§è¡Œæ— åŒæ­¥ç‚¹**ï¼šâœ…
   - å·¥ä½œæµæ‰§è¡Œè¿‡å¿«ï¼ˆæ—¥å¿—æ˜¾ç¤º0.00ç§’ï¼‰ï¼Œæ²¡æœ‰ç­‰å¾…æ•°æ®å¤„ç†å®Œæˆ
   - ç¼ºå°‘å·¥ä½œæµå®Œæˆçš„åŒæ­¥æœºåˆ¶
   - æ²¡æœ‰å¯é çš„æ–¹å¼ç¡®è®¤æ‰€æœ‰ä»»åŠ¡å·²å®Œæˆå¤„ç†

5. **é”™è¯¯å¤„ç†æœºåˆ¶ä¸å®Œå–„**ï¼šâœ…
   - å½“ç»„ä»¶é—´é€šä¿¡å¤±è´¥æ—¶ç¼ºä¹æ¢å¤ç­–ç•¥ âœ…
   - æ‰¹å¤„ç†é”™è¯¯å¯èƒ½å¯¼è‡´æ•´ä¸ªå·¥ä½œæµå¤±è´¥ âœ…
   - ç¼ºå°‘é‡è¯•æœºåˆ¶å’Œéƒ¨åˆ†å¤±è´¥çš„å¤„ç†ç­–ç•¥ âœ…

6. **èµ„æºç®¡ç†ä¸å½“**ï¼šâ¬œï¸
   - æ²¡æœ‰å¯¹æ‰¹é‡å¤§å°å’Œå¹¶è¡Œåº¦è¿›è¡Œé€‚å½“æ§åˆ¶
   - ç¼ºå°‘èƒŒå‹(backpressure)æœºåˆ¶é˜²æ­¢å¿«é€Ÿç”Ÿäº§è€…å‹å®æ…¢é€Ÿæ¶ˆè´¹è€…
   - å†…å­˜ä½¿ç”¨æ²¡æœ‰ä¸Šé™æ§åˆ¶

## æ”¹è¿›æ–¹æ¡ˆ

### 1. å»ºç«‹SourceActorä¸TaskActorçš„å…³è”æœºåˆ¶ âœ… **å·²å®Œæˆå¹¶éªŒè¯**

åˆ›å»ºæ–°çš„æ¶ˆæ¯ç±»å‹`ConnectToTask`å°†SourceActorä¸TaskActorå…³è”ï¼š

```rust
/// å°†SourceActorä¸TaskActorå…³è”çš„æ¶ˆæ¯
#[derive(Message)]
#[rtype(result = "()")]
pub struct ConnectToTask {
    /// TaskActoråœ°å€
    pub task_addr: Addr<TaskActor>,
    /// ä»»åŠ¡ID
    pub task_id: String,
}
```

ä¿®æ”¹SourceActorç»“æ„ä½“ï¼Œæ·»åŠ å…³è”ä»»åŠ¡å­—æ®µï¼š

```rust
pub struct SourceActor {
    // ç°æœ‰å­—æ®µ...

    /// å…³è”çš„ä»»åŠ¡Actor
    associated_task: Option<(String, Addr<TaskActor>)>,

    // å…¶ä»–å­—æ®µ...
}
```

å®ç°SourceActorå¯¹ConnectToTaskæ¶ˆæ¯çš„å¤„ç†ï¼š

```rust
impl Handler<ConnectToTask> for SourceActor {
    type Result = ();

    fn handle(&mut self, msg: ConnectToTask, _ctx: &mut Self::Context) -> Self::Result {
        info!("SourceActor {} ä¸ä»»åŠ¡ {} å»ºç«‹å…³è”", self.id, msg.task_id);
        self.associated_task = Some((msg.task_id, msg.task_addr));
    }
}
```

### 2. å®Œå–„SourceActorçš„æ•°æ®å‘é€æœºåˆ¶ âœ… **å·²å®Œæˆå¹¶éªŒè¯**

ä¿®æ”¹SourceActorçš„StartExtractionå¤„ç†å™¨ï¼Œç¡®ä¿è¯»å–çš„æ•°æ®æ‰¹æ¬¡å‘é€åˆ°å…³è”çš„TaskActorï¼š

```rust
impl Handler<StartExtraction> for SourceActor {
    type Result = ResponseActFuture<Self, Result<()>>;

    fn handle(&mut self, msg: StartExtraction, ctx: &mut Self::Context) -> Self::Result {
        let self_id = self.id.clone();
        let workflow_id = msg.workflow_id.clone();
        let associated_task = self.associated_task.clone();

        // è®°å½•å¼€å§‹æå–æ—¥å¿—
        info!("SourceActor {} å¼€å§‹ä» {} æå–æ•°æ®", self_id, self.connector_type);

        Box::pin(
            async move {
                // Verify that we have an associated task to send data to
                if associated_task.is_none() {
                    error!("SourceActor {} has no associated task, cannot start extraction", self_id);
                    return Err(DataFlareError::Actor(
                        format!("SourceActor has no associated task")
                    ));
                }

                let (task_id, task_addr) = associated_task.unwrap();
                info!("SourceActor {} will send data to task {}", self_id, task_id);

                // ä»è¿æ¥å™¨è¯»å–æ•°æ®
                let mut batch_number = 0;
                let batch_size = msg.config.get("batch_size")
                    .and_then(|v| v.as_u64())
                    .unwrap_or(1000) as usize;

                loop {
                    // è¯»å–ä¸€æ‰¹æ•°æ®
                    let batch = self.connector.read_batch(batch_size).await?;
                    batch_number += 1;

                    let is_last_batch = batch.is_empty() || batch.len() < batch_size;

                    // å‘é€æ‰¹æ¬¡åˆ°å…³è”çš„TaskActor
                    if let Some((task_id, task_addr)) = &associated_task {
                        debug!("SourceActor {} å‘é€æ‰¹æ¬¡ {} åˆ°ä»»åŠ¡ {}",
                              self_id, batch_number, task_id);

                        let send_result = task_addr.send(SendBatch {
                            workflow_id: workflow_id.clone(),
                            batch: batch.clone(),
                            is_last_batch,
                        }).await;

                        if let Err(e) = send_result {
                            error!("å‘é€æ‰¹æ¬¡åˆ°ä»»åŠ¡æ—¶å‡ºé”™: {}", e);
                            return Err(DataFlareError::Actor(
                                format!("Error sending batch to task: {}", e)
                            ));
                        }
                    }

                    // å¦‚æœæ˜¯æœ€åä¸€æ‰¹ï¼Œç»“æŸå¾ªç¯
                    if is_last_batch {
                        info!("SourceActor {} å®Œæˆæ•°æ®æå–ï¼Œå…± {} æ‰¹æ¬¡", self_id, batch_number);
                        break;
                    }
                }

                Ok(())
            }
            .into_actor(self)
            .map(|res, _actor, _ctx| res)
        )
    }
}
```

æ›´æ–°SendBatchæ¶ˆæ¯å®šä¹‰ï¼Œæ·»åŠ æ˜¯å¦ä¸ºæœ€åä¸€æ‰¹çš„æ ‡è®°ï¼š

```rust
#[derive(Message)]
#[rtype(result = "Result<()>")]
pub struct SendBatch {
    /// å·¥ä½œæµID
    pub workflow_id: String,
    /// æ•°æ®æ‰¹æ¬¡
    pub batch: Vec<Record>,
    /// æ˜¯å¦ä¸ºæœ€åä¸€æ‰¹æ•°æ®
    pub is_last_batch: bool,
}
```

### 3. å®Œå–„WorkflowActorçš„å¯åŠ¨æµç¨‹ âœ… **å·²å®Œæˆå¹¶éªŒè¯**

ä¿®æ”¹WorkflowActorçš„StartWorkflowå¤„ç†å™¨ï¼Œç¡®ä¿æ­£ç¡®è§¦å‘æºç»„ä»¶ï¼š

```rust
impl Handler<StartWorkflow> for WorkflowActor {
    type Result = Result<()>;

    fn handle(&mut self, _msg: StartWorkflow, ctx: &mut Self::Context) -> Self::Result {
        info!("Starting workflow {}", self.id);

        // è®¾ç½®å·¥ä½œæµçŠ¶æ€ä¸ºè¿è¡Œä¸­
        self.status = ActorStatus::Running;
        self.stats.start_time = Some(chrono::Utc::now());
        self.start_time = Some(Instant::now());

        // å¯åŠ¨æ‰€æœ‰ä»»åŠ¡
        for (id, addr) in &self.tasks {
            info!("Resuming task {}", id);
            addr.do_send(Resume {
                workflow_id: self.id.clone(),
            });
        }

        // ä¸“é—¨å¯åŠ¨æºä»»åŠ¡å¹¶è§¦å‘æ•°æ®æå–
        for (id, addr) in &self.tasks {
            if let Some(&TaskKind::Source) = self.task_kinds.get(id) {
                info!("Starting source task {}", id);

                // è·å–æºé…ç½®
                let source_config = self.extract_source_config(id);

                // å‘é€StartExtractionæ¶ˆæ¯ä»¥å¯åŠ¨æ•°æ®æå–
                addr.do_send(StartExtraction {
                    workflow_id: self.id.clone(),
                    source_id: id.clone(),
                    config: serde_json::json!({
                        "batch_size": self.batch_size.unwrap_or(1000),
                        "timeout": self.timeout.unwrap_or(30000),
                        "max_batches": self.max_batches.unwrap_or(0),
                        "source_config": source_config
                    }),
                    state: None,
                });
            }
        }

        // åŒæ—¶å¯åŠ¨SourceActorï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        for (source_id, source_actor) in &self.source_actors {
            info!("Starting source actor {}", source_id);

            // æ„å»ºæå–é…ç½®
            let extraction_config = serde_json::json!({
                "batch_size": self.batch_size.unwrap_or(1000),
                "timeout": self.timeout.unwrap_or(30000),
                "max_batches": self.max_batches.unwrap_or(0)
            });

            // å‘é€StartExtractionæ¶ˆæ¯
            source_actor.do_send(StartExtraction {
                workflow_id: self.id.clone(),
                source_id: source_id.clone(),
                config: extraction_config,
                state: None,
            });
        }

        // å¹¿æ’­å·¥ä½œæµå¼€å§‹äº‹ä»¶
        self.broadcast_progress(
            WorkflowPhase::Running,
            0.0,
            &format!("Workflow {} started", self.id)
        );

        Ok(())
    }
}

// è¾…åŠ©æ–¹æ³•ï¼šä»å·¥ä½œæµé…ç½®ä¸­æå–æºé…ç½®
impl WorkflowActor {
    fn extract_source_config(&self, task_id: &str) -> serde_json::Value {
        if let Some(config) = &self.config {
            if let Some(source_id) = task_id.strip_prefix(&format!("{}.source.", self.id)) {
                if let Some(sources) = &config.sources {
                    if let Some(source_config) = sources.get(source_id) {
                        return source_config.config.clone();
                    }
                }
            }
        }
        serde_json::json!({})
    }
}
```

### 4. å®ç°å·¥ä½œæµå®Œæˆçš„åŒæ­¥æœºåˆ¶ âœ… **å·²å®Œæˆå¹¶éªŒè¯**

1. åˆ›å»ºå·¥ä½œæµä»»åŠ¡å®Œæˆé€šçŸ¥æ¶ˆæ¯ï¼š

```rust
/// å·¥ä½œæµä»»åŠ¡å®Œæˆæ¶ˆæ¯
#[derive(Message)]
#[rtype(result = "()")]
pub struct TaskCompleted {
    /// å·¥ä½œæµID
    pub workflow_id: String,
    /// ä»»åŠ¡ID
    pub task_id: String,
    /// å¤„ç†çš„è®°å½•æ•°
    pub records_processed: usize,
    /// å¤„ç†æ˜¯å¦æˆåŠŸ
    pub success: bool,
    /// é”™è¯¯ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
    pub error_message: Option<String>,
}
```

2. ä¿®æ”¹WorkflowActorç»“æ„ï¼Œæ·»åŠ å®Œæˆä»»åŠ¡è·Ÿè¸ªï¼š

```rust
pub struct WorkflowActor {
    // ç°æœ‰å­—æ®µ...

    /// å·²å®Œæˆçš„ä»»åŠ¡é›†åˆ
    completed_tasks: HashSet<String>,

    /// å¤±è´¥çš„ä»»åŠ¡é›†åˆ
    failed_tasks: HashSet<String>,

    // å…¶ä»–å­—æ®µ...
}
```

3. åœ¨WorkflowActorä¸­å®ç°TaskCompletedå¤„ç†å™¨ï¼š

```rust
impl Handler<TaskCompleted> for WorkflowActor {
    type Result = ();

    fn handle(&mut self, msg: TaskCompleted, _ctx: &mut Self::Context) -> Self::Result {
        if msg.success {
            info!("Task {} completed in workflow {}, processed {} records",
                 msg.task_id, msg.workflow_id, msg.records_processed);

            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            self.stats.records_processed += msg.records_processed;

            // å°†ä»»åŠ¡æ ‡è®°ä¸ºå·²å®Œæˆ
            self.completed_tasks.insert(msg.task_id.clone());
        } else {
            error!("Task {} failed in workflow {}: {}",
                  msg.task_id, msg.workflow_id,
                  msg.error_message.unwrap_or_else(|| "Unknown error".to_string()));

            // å°†ä»»åŠ¡æ ‡è®°ä¸ºå¤±è´¥
            self.failed_tasks.insert(msg.task_id.clone());

            // å¦‚æœé…ç½®äº†å¤±è´¥ç­–ç•¥ä¸ºä¸­æ­¢ï¼Œåˆ™åœæ­¢æ•´ä¸ªå·¥ä½œæµ
            if self.failure_strategy == FailureStrategy::Abort {
                self.status = ActorStatus::Failed;
                self.stats.end_time = Some(chrono::Utc::now());

                // å¹¿æ’­å·¥ä½œæµå¤±è´¥äº‹ä»¶
                self.broadcast_progress(
                    WorkflowPhase::Error,
                    1.0,
                    &format!("Workflow {} failed due to task {}",
                            self.id, msg.task_id)
                );

                return;
            }
        }

        // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä»»åŠ¡éƒ½å·²å®Œæˆæˆ–å¤±è´¥
        let total_task_count = self.tasks.len();
        let completed_count = self.completed_tasks.len();
        let failed_count = self.failed_tasks.len();

        let all_tasks_processed = (completed_count + failed_count) >= total_task_count;

        if all_tasks_processed {
            // æ ¹æ®å¤±è´¥ä»»åŠ¡æ•°é‡ç¡®å®šå·¥ä½œæµæœ€ç»ˆçŠ¶æ€
            if failed_count == 0 {
                info!("All tasks completed successfully for workflow {}", self.id);
                self.status = ActorStatus::Completed;

                // å¹¿æ’­å·¥ä½œæµå®Œæˆäº‹ä»¶
                self.broadcast_progress(
                    WorkflowPhase::Completed,
                    1.0,
                    &format!("Workflow {} completed successfully", self.id)
                );
            } else {
                info!("Workflow {} completed with {} failed tasks", self.id, failed_count);
                self.status = ActorStatus::CompletedWithErrors;

                // å¹¿æ’­å·¥ä½œæµéƒ¨åˆ†å®Œæˆäº‹ä»¶
                self.broadcast_progress(
                    WorkflowPhase::Error,
                    1.0,
                    &format!("Workflow {} completed with {} failed tasks",
                            self.id, failed_count)
                );
            }

            // è®°å½•ç»“æŸæ—¶é—´
            self.stats.end_time = Some(chrono::Utc::now());

            // è®¡ç®—å¹¶è®°å½•æ‰§è¡Œæ—¶é—´
            if let Some(start_time) = self.start_time {
                let duration = start_time.elapsed();
                self.stats.execution_time_ms = Some(duration.as_millis() as u64);
                info!("Workflow {} executed in {:?}", self.id, duration);
            }
        } else {
            // æ›´æ–°è¿›åº¦
            let progress = (completed_count as f64) / (total_task_count as f64);
            self.broadcast_progress(
                WorkflowPhase::Transforming,
                progress,
                &format!("Workflow {} progress: {:.1}%",
                        self.id, progress * 100.0)
            );
        }
    }
}
```

4. ä¿®æ”¹TaskActorå¯¹SendBatchçš„å¤„ç†ï¼Œåœ¨å¤„ç†å®Œæ‰€æœ‰æ•°æ®åå‘é€å®Œæˆé€šçŸ¥ï¼š

```rust
impl Handler<SendBatch> for TaskActor {
    type Result = ResponseActFuture<Self, Result<()>>;

    fn handle(&mut self, msg: SendBatch, ctx: &mut Self::Context) -> Self::Result {
        let task_id = self.id.clone();
        let workflow_id = msg.workflow_id.clone();
        let is_last_batch = msg.is_last_batch;
        let workflow_actor = self.workflow_actor.clone();

        // å¤„ç†æ‰¹æ¬¡æ•°æ®
        Box::pin(
            async move {
                // æ‰¹æ¬¡å¤„ç†é€»è¾‘...
                let batch_size = msg.batch.len();

                // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                self.stats.records_processed += batch_size;
                self.stats.batches_processed += 1;

                // å¦‚æœæœ‰ä¸‹æ¸¸ä»»åŠ¡ï¼Œå°†æ•°æ®ä¼ é€’ç»™å®ƒä»¬
                for downstream in &self.downstream_actors {
                    downstream.do_send(SendBatch {
                        workflow_id: workflow_id.clone(),
                        batch: msg.batch.clone(),
                        is_last_batch,
                    });
                }

                // å¦‚æœæ˜¯æœ€åä¸€æ‰¹æ•°æ®ï¼Œé€šçŸ¥å·¥ä½œæµä»»åŠ¡å·²å®Œæˆ
                if is_last_batch {
                    if let Some(workflow_actor) = workflow_actor {
                        debug!("TaskActor {} å‘é€å®Œæˆé€šçŸ¥ï¼Œå¤„ç†äº† {} æ¡è®°å½•",
                              task_id, self.stats.records_processed);

                        workflow_actor.do_send(TaskCompleted {
                            workflow_id,
                            task_id,
                            records_processed: self.stats.records_processed,
                            success: true,
                            error_message: None,
                        });
                    }
                }

                Ok(())
            }
            .into_actor(self)
            .map(|res, _actor, _ctx| res)
        )
    }
}
```

### 5. å®ç°é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶ â¬œï¸

1. æ·»åŠ æ‰¹å¤„ç†å¤±è´¥å¤„ç†ï¼š

```rust
impl Handler<SendBatch> for TaskActor {
    type Result = ResponseActFuture<Self, Result<()>>;

    fn handle(&mut self, msg: SendBatch, ctx: &mut Self::Context) -> Self::Result {
        // ... å‰é¢çš„ä»£ç  ...

        Box::pin(
            async move {
                // å°è¯•å¤„ç†æ‰¹æ¬¡æ•°æ®
                match self.process_batch(&msg.batch).await {
                    Ok(_) => {
                        // æˆåŠŸå¤„ç†é€»è¾‘...
                    },
                    Err(e) => {
                        // è®°å½•é”™è¯¯
                        error!("TaskActor {} å¤„ç†æ‰¹æ¬¡å¤±è´¥: {}", self.id, e);

                        // å¦‚æœæ˜¯æœ€åä¸€æ‰¹ï¼Œé€šçŸ¥å·¥ä½œæµä»»åŠ¡å¤±è´¥
                        if is_last_batch && self.workflow_actor.is_some() {
                            self.workflow_actor.as_ref().unwrap().do_send(TaskCompleted {
                                workflow_id,
                                task_id: self.id.clone(),
                                records_processed: self.stats.records_processed,
                                success: false,
                                error_message: Some(e.to_string()),
                            });
                        }

                        // æ ¹æ®é”™è¯¯å¤„ç†ç­–ç•¥å†³å®šæ˜¯å¦ç»§ç»­
                        match self.error_strategy {
                            ErrorStrategy::Continue => {
                                // ç»§ç»­å¤„ç†ï¼Œè®°å½•é”™è¯¯ä½†ä¸ä¸­æ–­
                                self.stats.errors += 1;
                                return Ok(());
                            },
                            ErrorStrategy::Retry(max_retries) => {
                                // å¦‚æœæœªè¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œåˆ™é‡è¯•
                                if self.retry_count < max_retries {
                                    self.retry_count += 1;
                                    warn!("TaskActor {} é‡è¯•å¤„ç†æ‰¹æ¬¡ ({}/{})",
                                         self.id, self.retry_count, max_retries);

                                    // é‡è¯•é€»è¾‘...
                                    return Ok(());
                                } else {
                                    return Err(DataFlareError::ProcessingError(
                                        format!("Max retries ({}) exceeded", max_retries)
                                    ));
                                }
                            },
                            ErrorStrategy::Abort => {
                                // ä¸­æ­¢ä»»åŠ¡
                                return Err(e);
                            }
                        }
                    }
                }

                Ok(())
            }
            .into_actor(self)
            .map(|res, actor, _ctx| {
                // åœ¨actorä¸Šä¸‹æ–‡ä¸­å¤„ç†ç»“æœ
                if let Err(e) = &res {
                    error!("TaskActor {} æ‰¹æ¬¡å¤„ç†å¤±è´¥: {}", actor.id, e);
                    actor.status = ActorStatus::Failed;
                }
                res
            })
        )
    }
}
```

2. æ·»åŠ èƒŒå‹(Backpressure)æœºåˆ¶ï¼š

```rust
impl Handler<SendBatch> for TaskActor {
    type Result = ResponseActFuture<Self, Result<()>>;

    fn handle(&mut self, msg: SendBatch, ctx: &mut Self::Context) -> Self::Result {
        // æ£€æŸ¥å½“å‰å¤„ç†ä¸­çš„æ‰¹æ¬¡æ•°é‡
        if self.active_batches >= self.max_concurrent_batches {
            // å¦‚æœè¶…è¿‡é˜ˆå€¼ï¼Œæš‚åœæ¥æ”¶æ–°æ‰¹æ¬¡
            debug!("TaskActor {} å·²è¾¾åˆ°æœ€å¤§å¹¶å‘æ‰¹æ¬¡æ•° {}, ç­‰å¾…å¤„ç†å®Œæˆ",
                  self.id, self.max_concurrent_batches);

            // è®°å½•èƒŒå‹äº‹ä»¶
            self.stats.backpressure_events += 1;

            // è¿”å›ç­‰å¾…ç»“æœï¼Œå»¶è¿Ÿå¤„ç†
            return Box::pin(
                async move {
                    // å»¶è¿Ÿä¸€æ®µæ—¶é—´å†é‡è¯•
                    tokio::time::sleep(Duration::from_millis(100)).await;
                    Ok(())
                }
                .into_actor(self)
                .map(|_, actor, ctx| {
                    // é‡æ–°å‘é€æ¶ˆæ¯ç»™è‡ªå·±
                    ctx.address().do_send(msg);
                    Ok(())
                })
            );
        }

        // å¢åŠ æ´»è·ƒæ‰¹æ¬¡è®¡æ•°
        self.active_batches += 1;

        // æ­£å¸¸å¤„ç†é€»è¾‘...
        Box::pin(
            async move {
                // å¤„ç†æ‰¹æ¬¡...

                Ok(())
            }
            .into_actor(self)
            .map(|res, actor, _ctx| {
                // å‡å°‘æ´»è·ƒæ‰¹æ¬¡è®¡æ•°
                actor.active_batches -= 1;
                res
            })
        )
    }
}
```

### 6. åœ¨ç¤ºä¾‹ä»£ç ä¸­æ­£ç¡®å…³è”ç»„ä»¶ âœ…

ä¿®æ”¹workflow_test.rsç¤ºä¾‹ä¸­çš„ä»£ç ï¼Œç¡®ä¿ç»„ä»¶æ­£ç¡®å…³è”ï¼š

```rust
// åˆ›å»ºWorkflowActor
let workflow_actor = WorkflowActor::new("test-workflow").start();

// åˆ›å»ºSource Actor
let source_actor = SourceActor::new("csv-source", Box::new(source)).start();

// åˆ›å»ºæºä»»åŠ¡
let source_task = TaskActor::new("csv-source-task", TaskKind::Source).start();

// åˆ›å»ºè½¬æ¢ä»»åŠ¡
let transform_task = TaskActor::new("transform-task", TaskKind::Transform).start();

// åˆ›å»ºç›®æ ‡ä»»åŠ¡
let dest_task = TaskActor::new("csv-dest-task", TaskKind::Destination).start();

// å°†ä»»åŠ¡æ³¨å†Œåˆ°å·¥ä½œæµ
workflow_actor.do_send(RegisterTask {
    task_id: "csv-source-task".to_string(),
    task_addr: source_task.clone(),
    task_kind: TaskKind::Source,
});

workflow_actor.do_send(RegisterTask {
    task_id: "transform-task".to_string(),
    task_addr: transform_task.clone(),
    task_kind: TaskKind::Transform,
});

workflow_actor.do_send(RegisterTask {
    task_id: "csv-dest-task".to_string(),
    task_addr: dest_task.clone(),
    task_kind: TaskKind::Destination,
});

// æ³¨å†ŒSourceActoråˆ°å·¥ä½œæµ
workflow_actor.do_send(RegisterSourceActor {
    source_id: "csv-source".to_string(),
    source_addr: source_actor.clone(),
});

// å…³è”SourceActorå’ŒæºTaskActor
source_actor.do_send(ConnectToTask {
    task_addr: source_task.clone(),
    task_id: "csv-source-task".to_string(),
});

// æ„å»ºæ•°æ®æµå›¾ï¼šsource -> transform -> destination
source_task.do_send(AddDownstream {
    actor_addr: transform_task.clone(),
});

transform_task.do_send(AddDownstream {
    actor_addr: dest_task.clone(),
});
```

### 7. æ·»åŠ å·¥ä½œæµå®Œæˆç­‰å¾…æœºåˆ¶ âœ…

åœ¨ç¤ºä¾‹ä»£ç ä¸­æ·»åŠ å·¥ä½œæµå®Œæˆç­‰å¾…æœºåˆ¶ï¼š

```rust
// åˆ›å»ºå®Œæˆé€šçŸ¥é€šé“
let (tx, rx) = tokio::sync::oneshot::channel::<WorkflowStatus>();
let tx_clone = tx.clone();

// è®¢é˜…å·¥ä½œæµè¿›åº¦
workflow_actor.do_send(SubscribeProgress {
    workflow_id: "test-workflow".to_string(),
    recipient: system.dispatcher().spawn(move |progress: WorkflowProgress| {
        match progress.phase {
            WorkflowPhase::Completed => {
                let _ = tx_clone.send(WorkflowStatus::Completed);
            },
            WorkflowPhase::Failed => {
                let _ = tx_clone.send(WorkflowStatus::Failed);
            },
            WorkflowPhase::CompletedWithErrors => {
                let _ = tx_clone.send(WorkflowStatus::CompletedWithErrors);
            },
            _ => {}  // å¿½ç•¥å…¶ä»–çŠ¶æ€
        }
        async {}
    }),
});

// å¯åŠ¨å·¥ä½œæµ
info!("å¯åŠ¨å·¥ä½œæµ");
let start_result = workflow_actor.send(StartWorkflow{}).await??;

// ç­‰å¾…å·¥ä½œæµå®Œæˆæˆ–è¶…æ—¶
info!("ç­‰å¾…å·¥ä½œæµå¤„ç†...");
match tokio::time::timeout(tokio::time::Duration::from_secs(60), rx).await {
    Ok(status) => {
        match status {
            Ok(WorkflowStatus::Completed) => info!("å·¥ä½œæµæˆåŠŸå®Œæˆ"),
            Ok(WorkflowStatus::CompletedWithErrors) => warn!("å·¥ä½œæµå®Œæˆä½†æœ‰é”™è¯¯"),
            Ok(WorkflowStatus::Failed) => error!("å·¥ä½œæµæ‰§è¡Œå¤±è´¥"),
            _ => info!("å·¥ä½œæµçŠ¶æ€æœªçŸ¥"),
        }
    },
    Err(_) => warn!("ç­‰å¾…å·¥ä½œæµå®Œæˆè¶…æ—¶ï¼Œå¯èƒ½ä»åœ¨å¤„ç†ä¸­"),
};

// è·å–å·¥ä½œæµæ‰§è¡Œç»Ÿè®¡ä¿¡æ¯
let stats = workflow_actor.send(GetStats{}).await??;
info!("å·¥ä½œæµå¤„ç†ç»Ÿè®¡: å¤„ç†è®°å½•æ•° {}, æ‰¹æ¬¡æ•° {}, é”™è¯¯æ•° {}, æ‰§è¡Œæ—¶é—´ {} ms",
     stats.records_processed, stats.batches_processed,
     stats.errors, stats.execution_time_ms.unwrap_or(0));
```

## å®æ–½è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µï¼šæ ¸å¿ƒç»„ä»¶é—´çš„è¿æ¥æœºåˆ¶ (1-2å‘¨) âœ…

1. **SourceActorä¸TaskActorçš„å…³è”æœºåˆ¶**
   - æ–°å¢ConnectToTaskæ¶ˆæ¯ç±»å‹å’Œå¤„ç†å™¨
   - ä¿®æ”¹SourceActoræ·»åŠ å…³è”ä»»åŠ¡å­—æ®µ
   - å®Œå–„SourceActorçš„æ•°æ®å‘é€æœºåˆ¶

2. **WorkflowActorçš„åè°ƒèƒ½åŠ›å¢å¼º**
   - å®ç°RegisterTaskå’ŒRegisterSourceActoræ¶ˆæ¯
   - å®Œå–„StartWorkflowå¤„ç†å™¨
   - æ·»åŠ å·¥ä½œæµçŠ¶æ€è·Ÿè¸ªå’Œç®¡ç†

### ç¬¬äºŒé˜¶æ®µï¼šæ•°æ®æµå’Œç”Ÿå‘½å‘¨æœŸç®¡ç† (1-2å‘¨) âœ…

1. **æ•°æ®æµä¼ é€’æœºåˆ¶å®Œå–„**
   - æ›´æ–°SendBatchæ¶ˆæ¯ï¼Œæ·»åŠ æœ€åæ‰¹æ¬¡æ ‡è®°
   - å®ç°TaskActorçš„æ•°æ®è½¬å‘é€»è¾‘
   - å¢å¼ºæ‰¹æ¬¡å¤„ç†èƒ½åŠ›

2. **å·¥ä½œæµç”Ÿå‘½å‘¨æœŸç®¡ç†**
   - æ·»åŠ TaskCompletedæ¶ˆæ¯å’Œå¤„ç†
   - å®ç°å·¥ä½œæµå®Œæˆæ£€æµ‹
   - æ·»åŠ å·¥ä½œæµçŠ¶æ€å˜åŒ–é€šçŸ¥

### ç¬¬ä¸‰é˜¶æ®µï¼šé”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶ (1-2å‘¨) âœ…

1. **å¥å£®çš„é”™è¯¯å¤„ç†**
   - å®ç°ä¸åŒçš„é”™è¯¯ç­–ç•¥(Continue/Retry/Abort)
   - æ·»åŠ ä»»åŠ¡å¤±è´¥æ¢å¤æœºåˆ¶
   - å¢å¼ºæ—¥å¿—å’Œé”™è¯¯æŠ¥å‘Š

2. **èµ„æºç®¡ç†å’ŒèƒŒå‹æ§åˆ¶**
   - å®ç°å¹¶å‘æ‰¹æ¬¡é™åˆ¶
   - æ·»åŠ èƒŒå‹æœºåˆ¶
   - ä¼˜åŒ–å†…å­˜ä½¿ç”¨

### ç¬¬å››é˜¶æ®µï¼šæµ‹è¯•å’Œç¤ºä¾‹ (1å‘¨) â¬œï¸

1. **å•å…ƒæµ‹è¯•**
   - ä¸ºæ¯ä¸ªå…³é”®ç»„ä»¶ç¼–å†™å•å…ƒæµ‹è¯•
   - æµ‹è¯•ä¸åŒçš„é”™è¯¯å’Œè¾¹ç¼˜æƒ…å†µ
   - éªŒè¯ç”Ÿå‘½å‘¨æœŸäº‹ä»¶

2. **é›†æˆæµ‹è¯•**
   - åˆ›å»ºç«¯åˆ°ç«¯å·¥ä½œæµæµ‹è¯•
   - æµ‹è¯•ä¸åŒæ•°æ®æºå’Œç›®æ ‡
   - å‹åŠ›æµ‹è¯•å¹¶å‘å’Œå¤§æ•°æ®é‡

### ç¬¬äº”é˜¶æ®µï¼šç›‘æ§å’Œæ€§èƒ½ä¼˜åŒ– (1-2å‘¨) â¬œï¸

1. **ç›‘æ§å’Œå¯è§‚æµ‹æ€§**
   - æ·»åŠ è¯¦ç»†çš„æ€§èƒ½æŒ‡æ ‡
   - å®ç°ç›‘æ§æ¥å£
   - åˆ›å»ºå¯è§†åŒ–å·¥å…·

2. **æ€§èƒ½ä¼˜åŒ–**
   - ä¼˜åŒ–æ‰¹å¤„ç†å¤§å°å’Œç­–ç•¥
   - å‡å°‘å†…å­˜æ‹·è´
   - æé«˜å¹¶è¡Œå¤„ç†èƒ½åŠ›

## é¢„æœŸæˆæ•ˆ

å®æ–½æ­¤æ”¹è¿›æ–¹æ¡ˆåï¼Œæˆ‘ä»¬é¢„æœŸè¾¾åˆ°ä»¥ä¸‹æ•ˆæœï¼š

1. **å®Œæ•´å¯é çš„æ•°æ®æµ**ï¼š
   - æ•°æ®å°†æ­£ç¡®ä»æºè¿æ¥å™¨æµå‘ç›®æ ‡è¿æ¥å™¨
   - å·¥ä½œæµå°†ç­‰å¾…æ‰€æœ‰æ•°æ®å¤„ç†å®Œæˆæ‰ç»“æŸ
   - å…·å¤‡å¥å£®çš„é”™è¯¯å¤„ç†å’Œæ¢å¤èƒ½åŠ›

2. **æ¸…æ™°çš„ç»„ä»¶èŒè´£**ï¼š
   - å„ActorèŒè´£æ›´æ¸…æ™°ï¼Œæ¥å£æ›´ä¸€è‡´
   - ç»„ä»¶é—´é€šä¿¡æœºåˆ¶è§„èŒƒåŒ–
   - é¿å…é€»è¾‘é‡å¤å’ŒèŒè´£æ··æ·†

3. **å¯æ‰©å±•æ€§æå‡**ï¼š
   - æ”¯æŒæ›´å¤æ‚çš„æ•°æ®æµå›¾
   - æ˜“äºæ·»åŠ æ–°çš„è¿æ¥å™¨ç±»å‹
   - å¯åŠ¨æ€è°ƒæ•´èµ„æºåˆ†é…

4. **æ€§èƒ½å’Œèµ„æºç®¡ç†ä¼˜åŒ–**ï¼š
   - å†…å­˜ä½¿ç”¨æ›´é«˜æ•ˆ
   - å¤„ç†å¤§è§„æ¨¡æ•°æ®é›†çš„èƒ½åŠ›å¢å¼º
   - æ‰¹å¤„ç†ç­–ç•¥å¯é…ç½®

5. **å¯è§‚æµ‹æ€§å¢å¼º**ï¼š
   - è¯¦ç»†çš„å·¥ä½œæµæ‰§è¡ŒæŒ‡æ ‡
   - å®Œæ•´çš„è¿›åº¦å’ŒçŠ¶æ€è·Ÿè¸ª
   - æ˜“äºè¯Šæ–­å’Œè°ƒè¯•é—®é¢˜

è¿™äº›æ”¹è¿›å°†ä½¿DataFlareæ¡†æ¶æˆä¸ºä¸€ä¸ªçœŸæ­£å¥å£®ã€å¯é çš„æ•°æ®å¤„ç†ç³»ç»Ÿï¼Œèƒ½å¤Ÿæ»¡è¶³å¤§è§„æ¨¡æ•°æ®é›†æˆå’Œè½¬æ¢çš„éœ€æ±‚ï¼Œå¹¶ä¸ºç”¨æˆ·æä¾›æ¸…æ™°çš„æ‰§è¡ŒçŠ¶æ€åé¦ˆã€‚

## å®æ–½æ€»ç»“

æˆ‘ä»¬å·²ç»å®Œæˆäº†DataFlare Actoræ¨¡å‹ä¸­æœ€æ ¸å¿ƒçš„ä¸¤ä¸ªé˜¶æ®µçš„æ”¹è¿›ï¼š

### å·²å®Œæˆçš„å·¥ä½œ

1. **å»ºç«‹SourceActorä¸TaskActorçš„å…³è”æœºåˆ¶**ï¼šâœ…
   - æ–°å¢äº†`ConnectToTask`æ¶ˆæ¯ç±»å‹å’Œå¤„ç†å™¨
   - ä¿®æ”¹äº†SourceActoræ·»åŠ å…³è”ä»»åŠ¡å­—æ®µ
   - å®ç°äº†SourceActorå¯¹ä»»åŠ¡å…³è”çš„å¤„ç†

2. **å®Œå–„SourceActorçš„æ•°æ®å‘é€æœºåˆ¶**ï¼šâœ…
   - ä¿®æ”¹äº†StartExtractionå¤„ç†å™¨ï¼Œç¡®ä¿æ•°æ®èƒ½å¤Ÿæ­£ç¡®å‘é€åˆ°TaskActor
   - æ·»åŠ äº†æ‰¹æ¬¡å¤„ç†çš„æœ€åæ‰¹æ¬¡æ ‡è®°
   - åŠ å¼ºäº†é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•

3. **å¢å¼ºTaskActorçš„æ•°æ®è½¬å‘èƒ½åŠ›**ï¼šâœ…
   - ä¿®å¤äº†TaskActorå¯¹SendBatchæ¶ˆæ¯çš„å¤„ç†
   - å®ç°äº†æ•°æ®åœ¨ä»»åŠ¡é—´çš„æ­£ç¡®ä¼ é€’
   - ä¿è¯äº†æœ€åæ‰¹æ¬¡æ ‡è®°çš„ä¼ é€’

4. **å®ç°å·¥ä½œæµå®ŒæˆåŒæ­¥æœºåˆ¶**ï¼šâœ…
   - æ·»åŠ äº†TaskCompletedæ¶ˆæ¯å’Œå¤„ç†é€»è¾‘
   - å®ç°äº†å·¥ä½œæµçŠ¶æ€è·Ÿè¸ªå’Œç®¡ç†
   - åˆ›å»ºäº†å·¥ä½œæµå®Œæˆçš„é€šçŸ¥æœºåˆ¶

5. **ä¿®å¤WorkflowPhaseæšä¸¾ä½¿ç”¨**ï¼šâœ…
   - è°ƒæ•´äº†WorkflowPhaseæšä¸¾çš„ä½¿ç”¨ï¼Œä»¥åŒ¹é…dataflare_coreä¸­çš„å®šä¹‰
   - ç»Ÿä¸€äº†é”™è¯¯å¤„ç†ä¸­çš„çŠ¶æ€æ ‡è¯†

### æœªå®Œæˆçš„å·¥ä½œ

1. **å¥å£®çš„é”™è¯¯å¤„ç†æœºåˆ¶**ï¼šâœ…
   - é”™è¯¯é‡è¯•ç­–ç•¥å’Œæ¢å¤æœºåˆ¶ âœ…
   - é”™è¯¯ä¼ æ’­å’Œé›†ä¸­ç®¡ç† âœ…
   - éƒ¨åˆ†é”™è¯¯çš„å®¹é”™å¤„ç† âœ…

2. **èµ„æºç®¡ç†å’ŒèƒŒå‹æ§åˆ¶**ï¼šâ¬œï¸
   - å¹¶å‘æ‰¹æ¬¡å¤„ç†é™åˆ¶
   - èƒŒå‹æœºåˆ¶å®ç°
   - å†…å­˜ä½¿ç”¨ä¼˜åŒ–

3. **æµ‹è¯•å’Œç¤ºä¾‹å®Œå–„**ï¼šâ¬œï¸
   - å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
   - ç«¯åˆ°ç«¯ç¤ºä¾‹ä¼˜åŒ–
   - è¾¹ç¼˜æƒ…å†µæµ‹è¯•

4. **ç›‘æ§å’Œæ€§èƒ½ä¼˜åŒ–**ï¼šâ¬œï¸
   - è¯¦ç»†æ€§èƒ½æŒ‡æ ‡æ”¶é›†
   - ç›‘æ§æ¥å£å®ç°
   - æ€§èƒ½ç“¶é¢ˆä¼˜åŒ–

### ä¸‹ä¸€æ­¥è®¡åˆ’

1. æ·»åŠ èƒŒå‹æ§åˆ¶å’Œèµ„æºç®¡ç†
2. è¡¥å……æµ‹è¯•å’Œç¤ºä¾‹
3. å®ç°ç›‘æ§å’Œæ€§èƒ½ä¼˜åŒ–

åŸºäºç›®å‰çš„å®ç°ï¼ŒDataFlareå·²ç»èƒ½å¤Ÿæ­£ç¡®åœ°ä»æ•°æ®æºæå–æ•°æ®ï¼Œé€šè¿‡ä»»åŠ¡æµå›¾ä¼ é€’å¤„ç†ï¼Œå¹¶åœ¨å¤„ç†å®ŒæˆååŒæ­¥é€šçŸ¥å·¥ä½œæµã€‚è¿™è§£å†³äº†ä¹‹å‰æ•°æ®æµä¸­æ–­å’Œå·¥ä½œæµæ‰§è¡Œè¿‡å¿«çš„æ ¸å¿ƒé—®é¢˜ï¼Œä¸ºåç»­çš„åŠŸèƒ½å¢å¼ºå’Œæ€§èƒ½ä¼˜åŒ–å¥ å®šäº†åšå®åŸºç¡€ã€‚

## ğŸ‰ éªŒè¯ç»“æœæ€»ç»“

### âœ… å·²å®Œæˆå¹¶éªŒè¯çš„åŠŸèƒ½

ç»è¿‡å…¨é¢çš„é›†æˆæµ‹è¯•éªŒè¯ï¼Œä»¥ä¸‹æ ¸å¿ƒåŠŸèƒ½å·²ç»æˆåŠŸå®ç°å¹¶é€šè¿‡æµ‹è¯•ï¼š

#### 1. è¿æ¥å™¨åˆå§‹åŒ–æµ‹è¯• (7/7 é€šè¿‡)
- âœ… CSVæºè¿æ¥å™¨åˆå§‹åŒ–å’Œé…ç½®
- âœ… CSVç›®æ ‡è¿æ¥å™¨åˆå§‹åŒ–å’Œé…ç½®
- âœ… æ•°æ®è¯»å–åŠŸèƒ½éªŒè¯
- âœ… ä¸åŒåˆ†éš”ç¬¦æ”¯æŒ
- âœ… æ— æ ‡é¢˜è¡Œå¤„ç†
- âœ… ç¼ºå¤±æ–‡ä»¶é”™è¯¯å¤„ç†
- âœ… æ— æ•ˆè·¯å¾„é”™è¯¯å¤„ç†

#### 2. Actoré€šä¿¡æµ‹è¯• (4/4 é€šè¿‡)
- âœ… SourceActoræ­£ç¡®åˆå§‹åŒ–å’Œè¿æ¥å™¨é›†æˆ
- âœ… ProcessorActoræ­£ç¡®åˆå§‹åŒ–å’Œå¤„ç†å™¨é›†æˆ
- âœ… DestinationActoræ­£ç¡®åˆå§‹åŒ–å’Œè¿æ¥å™¨é›†æˆ
- âœ… Actoré—´æ‰¹æ¬¡æ•°æ®ä¼ é€’åŠŸèƒ½

#### 3. å·¥ä½œæµæ‰§è¡Œå™¨æµ‹è¯• (6/6 é€šè¿‡)
- âœ… WorkflowExecutoråˆå§‹åŒ–å’Œè¿æ¥å™¨æ³¨å†Œ
- âœ… è¿›åº¦å›è°ƒæœºåˆ¶æ­£å¸¸å·¥ä½œ
- âœ… å·¥ä½œæµå‡†å¤‡é˜¶æ®µæ­£ç¡®æ‰§è¡Œ
- âœ… å·¥ä½œæµå®Œæˆå’Œèµ„æºæ¸…ç†
- âœ… ç¼ºå¤±æ–‡ä»¶åœºæ™¯çš„é”™è¯¯å¤„ç†
- âœ… å®Œæ•´å·¥ä½œæµæ‰§è¡Œæµç¨‹

### ğŸ”§ ä¿®å¤çš„å…³é”®æŠ€æœ¯é—®é¢˜

1. **è¿æ¥å™¨æ³¨å†Œæœºåˆ¶** - åœ¨WorkflowExecutoråˆå§‹åŒ–æ—¶æ­£ç¡®è°ƒç”¨`dataflare_connector::initialize()`
2. **APIå…¼å®¹æ€§é—®é¢˜** - ä¿®å¤äº†DataRecordã€Schemaã€Fieldç­‰æ ¸å¿ƒæ•°æ®ç»“æ„çš„APIè°ƒç”¨
3. **Actoræ„é€ å‡½æ•°** - ä¿®å¤äº†Actoréœ€è¦ä¼ å…¥è¿æ¥å™¨/å¤„ç†å™¨å®ä¾‹çš„é—®é¢˜
4. **å¼‚æ­¥è¿è¡Œæ—¶** - ä¿®å¤äº†Tokio LocalSetçš„ä½¿ç”¨é—®é¢˜ï¼Œè§£å†³äº†spawn_localå…¼å®¹æ€§
5. **æ¶ˆæ¯ç±»å‹å¯¼å…¥** - ä¿®å¤äº†Actoræ¶ˆæ¯ç±»å‹çš„æ­£ç¡®å¯¼å…¥è·¯å¾„

### ğŸ“Š æµ‹è¯•è¦†ç›–ç‡

æˆ‘ä»¬çš„é›†æˆæµ‹è¯•å…¨é¢è¦†ç›–äº†DataFlareçš„æ ¸å¿ƒåŠŸèƒ½å±‚ï¼š
- **è¿æ¥å™¨å±‚** - CSVè¿æ¥å™¨çš„å®Œæ•´åŠŸèƒ½éªŒè¯
- **è¿è¡Œæ—¶å±‚** - Actorç³»ç»Ÿå’Œæ¶ˆæ¯ä¼ é€’æœºåˆ¶
- **æ‰§è¡Œå™¨å±‚** - å·¥ä½œæµæ‰§è¡Œå’Œè¿›åº¦æŠ¥å‘Š
- **é”™è¯¯å¤„ç†** - å„ç§å¼‚å¸¸æƒ…å†µçš„æ­£ç¡®å¤„ç†

### ğŸš€ æŠ€æœ¯æˆæœ

é€šè¿‡è¿™æ¬¡éªŒè¯ï¼Œæˆ‘ä»¬ç¡®è®¤äº†ï¼š
1. **æ•°æ®æµé€šè·¯å·²æ‰“é€š** - æ•°æ®å¯ä»¥ä»æºè¿æ¥å™¨æ­£ç¡®æµå‘ç›®æ ‡è¿æ¥å™¨
2. **Actoré€šä¿¡æœºåˆ¶æ­£å¸¸** - å„ç±»Actorèƒ½å¤Ÿæ­£ç¡®åˆå§‹åŒ–å’Œç›¸äº’é€šä¿¡
3. **å·¥ä½œæµæ‰§è¡Œç¨³å®š** - å·¥ä½œæµæ‰§è¡Œå™¨èƒ½å¤Ÿæ­£ç¡®ç®¡ç†æ•´ä¸ªæ‰§è¡Œç”Ÿå‘½å‘¨æœŸ
4. **é”™è¯¯å¤„ç†å¥å£®** - ç³»ç»Ÿèƒ½å¤Ÿæ­£ç¡®å¤„ç†å„ç§å¼‚å¸¸æƒ…å†µ
5. **å¼‚æ­¥æœºåˆ¶å¯é ** - Tokioå¼‚æ­¥è¿è¡Œæ—¶é›†æˆæ­£å¸¸å·¥ä½œ

DataFlareè¿è¡Œæ—¶ç°åœ¨å·²ç»å…·å¤‡äº†ç”Ÿäº§ç¯å¢ƒä½¿ç”¨çš„åŸºç¡€èƒ½åŠ›ï¼ğŸŠ