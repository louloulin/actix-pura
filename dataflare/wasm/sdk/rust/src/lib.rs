//! DataFlare WASM Plugin SDK for Rust
//! 
//! This SDK provides a high-level interface for developing DataFlare plugins in Rust
//! using the WebAssembly Component Model and WIT interfaces.

pub mod prelude;
pub mod types;
pub mod traits;
pub mod macros;
pub mod host;
pub mod error;

// Re-export commonly used types
pub use types::*;
pub use traits::*;
pub use error::{PluginError, PluginResult};

// WIT bindings (generated by wit-bindgen)
wit_bindgen::generate!({
    world: "dataflare-plugin",
    path: "../wit",
    exports: {
        "dataflare:core/plugin-metadata": PluginMetadataImpl,
        "dataflare:core/data-transformer": DataTransformerImpl,
    },
});

use crate::exports::dataflare::core::plugin_metadata::Guest as PluginMetadataGuest;
use crate::exports::dataflare::core::data_transformer::Guest as DataTransformerGuest;

/// Plugin metadata implementation
pub struct PluginMetadataImpl;

impl PluginMetadataGuest for PluginMetadataImpl {
    fn get_info() -> exports::dataflare::core::plugin_metadata::PluginInfo {
        PLUGIN_REGISTRY.with(|registry| {
            registry.borrow().get_info()
        })
    }
    
    fn get_component_type() -> exports::dataflare::core::plugin_metadata::ComponentType {
        PLUGIN_REGISTRY.with(|registry| {
            registry.borrow().get_component_type()
        })
    }
    
    fn get_capabilities() -> dataflare::core::types::Capabilities {
        PLUGIN_REGISTRY.with(|registry| {
            registry.borrow().get_capabilities()
        })
    }
    
    fn get_security_requirements() -> exports::dataflare::core::plugin_metadata::SecurityRequirements {
        PLUGIN_REGISTRY.with(|registry| {
            registry.borrow().get_security_requirements()
        })
    }
}

/// Data transformer implementation
pub struct DataTransformerImpl;

impl DataTransformerGuest for DataTransformerImpl {
    fn init(config: dataflare::core::types::Config) -> Result<(), String> {
        PLUGIN_REGISTRY.with(|registry| {
            registry.borrow_mut().init_transformer(config)
        })
    }
    
    fn transform(input: dataflare::core::types::DataRecord) -> Result<dataflare::core::types::DataRecord, String> {
        PLUGIN_REGISTRY.with(|registry| {
            registry.borrow_mut().transform(input)
        })
    }
    
    fn transform_batch(inputs: Vec<dataflare::core::types::DataRecord>) -> Result<Vec<dataflare::core::types::DataRecord>, String> {
        PLUGIN_REGISTRY.with(|registry| {
            registry.borrow_mut().transform_batch(inputs)
        })
    }
    
    fn get_capabilities() -> dataflare::core::types::Capabilities {
        PLUGIN_REGISTRY.with(|registry| {
            registry.borrow().get_capabilities()
        })
    }
    
    fn get_metrics() -> dataflare::core::types::Metrics {
        PLUGIN_REGISTRY.with(|registry| {
            registry.borrow().get_metrics()
        })
    }
    
    fn cleanup() -> Result<(), String> {
        PLUGIN_REGISTRY.with(|registry| {
            registry.borrow_mut().cleanup()
        })
    }
}

use std::cell::RefCell;

thread_local! {
    static PLUGIN_REGISTRY: RefCell<PluginRegistry> = RefCell::new(PluginRegistry::new());
}

/// Plugin registry for managing plugin instances
pub struct PluginRegistry {
    transformer: Option<Box<dyn DataTransformer>>,
    processor: Option<Box<dyn DataProcessor>>,
    filter: Option<Box<dyn DataFilter>>,
    source: Option<Box<dyn DataSource>>,
    destination: Option<Box<dyn DataDestination>>,
    aggregator: Option<Box<dyn DataAggregator>>,
    metadata: Option<PluginMetadata>,
}

impl PluginRegistry {
    pub fn new() -> Self {
        Self {
            transformer: None,
            processor: None,
            filter: None,
            source: None,
            destination: None,
            aggregator: None,
            metadata: None,
        }
    }
    
    pub fn register_transformer<T: DataTransformer + 'static>(&mut self, transformer: T) {
        self.transformer = Some(Box::new(transformer));
    }
    
    pub fn register_processor<T: DataProcessor + 'static>(&mut self, processor: T) {
        self.processor = Some(Box::new(processor));
    }
    
    pub fn register_metadata(&mut self, metadata: PluginMetadata) {
        self.metadata = Some(metadata);
    }
    
    pub fn get_info(&self) -> exports::dataflare::core::plugin_metadata::PluginInfo {
        if let Some(ref metadata) = self.metadata {
            exports::dataflare::core::plugin_metadata::PluginInfo {
                name: metadata.name.clone(),
                version: metadata.version.clone(),
                description: metadata.description.clone(),
                author: metadata.author.clone(),
                license: metadata.license.clone(),
                homepage: metadata.homepage.clone(),
                repository: metadata.repository.clone(),
            }
        } else {
            exports::dataflare::core::plugin_metadata::PluginInfo {
                name: "unknown".to_string(),
                version: "0.0.0".to_string(),
                description: "No description".to_string(),
                author: "Unknown".to_string(),
                license: "Unknown".to_string(),
                homepage: None,
                repository: None,
            }
        }
    }
    
    pub fn get_component_type(&self) -> exports::dataflare::core::plugin_metadata::ComponentType {
        if self.transformer.is_some() {
            exports::dataflare::core::plugin_metadata::ComponentType::Transformer
        } else if self.processor.is_some() {
            exports::dataflare::core::plugin_metadata::ComponentType::Processor
        } else if self.filter.is_some() {
            exports::dataflare::core::plugin_metadata::ComponentType::Filter
        } else if self.source.is_some() {
            exports::dataflare::core::plugin_metadata::ComponentType::Source
        } else if self.destination.is_some() {
            exports::dataflare::core::plugin_metadata::ComponentType::Destination
        } else if self.aggregator.is_some() {
            exports::dataflare::core::plugin_metadata::ComponentType::Aggregator
        } else {
            exports::dataflare::core::plugin_metadata::ComponentType::Processor
        }
    }
    
    pub fn get_capabilities(&self) -> dataflare::core::types::Capabilities {
        // Return default capabilities for now
        dataflare::core::types::Capabilities {
            supports_async: false,
            supports_streaming: true,
            supports_batch: true,
            supports_backpressure: false,
            max_batch_size: Some(1000),
        }
    }
    
    pub fn get_security_requirements(&self) -> exports::dataflare::core::plugin_metadata::SecurityRequirements {
        exports::dataflare::core::plugin_metadata::SecurityRequirements {
            requires_network: false,
            requires_filesystem: false,
            requires_env_vars: false,
            max_memory_mb: Some(64),
            max_execution_time_ms: Some(5000),
        }
    }
    
    pub fn init_transformer(&mut self, config: dataflare::core::types::Config) -> Result<(), String> {
        if let Some(ref mut transformer) = self.transformer {
            transformer.init(config).map_err(|e| e.to_string())
        } else {
            Err("No transformer registered".to_string())
        }
    }
    
    pub fn transform(&mut self, input: dataflare::core::types::DataRecord) -> Result<dataflare::core::types::DataRecord, String> {
        if let Some(ref mut transformer) = self.transformer {
            transformer.transform(input).map_err(|e| e.to_string())
        } else {
            Err("No transformer registered".to_string())
        }
    }
    
    pub fn transform_batch(&mut self, inputs: Vec<dataflare::core::types::DataRecord>) -> Result<Vec<dataflare::core::types::DataRecord>, String> {
        if let Some(ref mut transformer) = self.transformer {
            transformer.transform_batch(inputs).map_err(|e| e.to_string())
        } else {
            Err("No transformer registered".to_string())
        }
    }
    
    pub fn get_metrics(&self) -> dataflare::core::types::Metrics {
        dataflare::core::types::Metrics {
            execution_time_ms: 0.0,
            memory_usage_bytes: 0,
            throughput_per_sec: 0.0,
            error_rate: 0.0,
        }
    }
    
    pub fn cleanup(&mut self) -> Result<(), String> {
        if let Some(ref mut transformer) = self.transformer {
            transformer.cleanup().map_err(|e| e.to_string())
        } else {
            Ok(())
        }
    }
}

/// Plugin metadata structure
#[derive(Debug, Clone)]
pub struct PluginMetadata {
    pub name: String,
    pub version: String,
    pub description: String,
    pub author: String,
    pub license: String,
    pub homepage: Option<String>,
    pub repository: Option<String>,
}

/// Convenience macro for registering a plugin
#[macro_export]
macro_rules! register_plugin {
    ($plugin_type:ty, $metadata:expr) => {
        #[no_mangle]
        pub extern "C" fn _start() {
            $crate::PLUGIN_REGISTRY.with(|registry| {
                let mut registry = registry.borrow_mut();
                registry.register_metadata($metadata);
                
                // Create and register the plugin instance
                let plugin = <$plugin_type>::new();
                registry.register_transformer(plugin);
            });
        }
    };
}

/// Export the plugin
#[macro_export]
macro_rules! export_plugin {
    () => {
        export!(PluginMetadataImpl);
        export!(DataTransformerImpl);
    };
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_plugin_registry() {
        let mut registry = PluginRegistry::new();
        
        let metadata = PluginMetadata {
            name: "test-plugin".to_string(),
            version: "1.0.0".to_string(),
            description: "Test plugin".to_string(),
            author: "Test Author".to_string(),
            license: "MIT".to_string(),
            homepage: None,
            repository: None,
        };
        
        registry.register_metadata(metadata);
        
        let info = registry.get_info();
        assert_eq!(info.name, "test-plugin");
        assert_eq!(info.version, "1.0.0");
    }
}
